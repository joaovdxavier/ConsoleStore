import org.aspectjml.ajmlrac.runtime.*;
public privileged aspect AspectJMLRac$JMLRacPost4Project {

/** Generated by AspectJML to recover checked exceptions. *
  *  This is based on the exception introduction pattern by Laddad. */
  after(final Main object$rac) throwing(JMLInternalRuntimeException rac$e)
    throws java.io.IOException : (execution(* Main..*+.*(..) throws java.io.IOException) ||
    execution(Main..*+.new(..) throws java.io.IOException) ||
execution(* Main+.*(..) throws java.io.IOException) ||
    execution(Main+.new(..) throws java.io.IOException)) && 
   target(object$rac) {
    Throwable cause = rac$e.getCause();
    if(cause instanceof java.io.IOException) {
      throw (java.io.IOException)cause;
    }
    JMLChecker.rethrowUncheckedException(cause);
  }
  after(final Main object$rac) throwing(JMLInternalRuntimeException rac$e)
    throws exceptions.NotLoggedInException : (execution(* Main..*+.*(..) throws exceptions.NotLoggedInException) ||
    execution(Main..*+.new(..) throws exceptions.NotLoggedInException) ||
execution(* Main+.*(..) throws exceptions.NotLoggedInException) ||
    execution(Main+.new(..) throws exceptions.NotLoggedInException)) && 
   target(object$rac) {
    Throwable cause = rac$e.getCause();
    if(cause instanceof exceptions.NotLoggedInException) {
      throw (exceptions.NotLoggedInException)cause;
    }
    JMLChecker.rethrowUncheckedException(cause);
  }
  after(final Main object$rac) throwing(JMLInternalRuntimeException rac$e)
    throws exceptions.NonExistentProductId : (execution(* Main..*+.*(..) throws exceptions.NonExistentProductId) ||
    execution(Main..*+.new(..) throws exceptions.NonExistentProductId) ||
execution(* Main+.*(..) throws exceptions.NonExistentProductId) ||
    execution(Main+.new(..) throws exceptions.NonExistentProductId)) && 
   target(object$rac) {
    Throwable cause = rac$e.getCause();
    if(cause instanceof exceptions.NonExistentProductId) {
      throw (exceptions.NonExistentProductId)cause;
    }
    JMLChecker.rethrowUncheckedException(cause);
  }

/** Generated by AspectJML to enable modular signals_only checking (XCS enabled) */
  after(final Main object$rac): (execution( * Main..*+.*(..))
          || execution(Main..*+.new(..))
          || execution( * Main+.*(..))
          || execution(Main+.new(..))) && 
   this(object$rac) {
   JMLChecker.hasAnyThrownExceptionalPostconditionSignalsOnly();
  }

/** Generated by AspectJML to enhance error reporting (Execution Site enabled) */
  after() throwing (Throwable rac$e): (execution( * Main..*+.*(..))
          || execution(Main..*+.new(..))
          || execution( * Main+.*(..))
          || execution(Main+.new(..))){
    JMLChecker.hideAjmlSpecificStackTrace(rac$e);
    JMLChecker.rethrowJMLAssertionError(rac$e);
  }

/** Generated by AspectJML to recover checked exceptions. *
  *  This is based on the exception introduction pattern by Laddad. */
  after(final com.eclipsesource.json.Json object$rac) throwing(JMLInternalRuntimeException rac$e)
    throws java.io.IOException : (execution(* com.eclipsesource.json.Json..*+.*(..) throws java.io.IOException) ||
    execution(com.eclipsesource.json.Json..*+.new(..) throws java.io.IOException) ||
execution(* com.eclipsesource.json.Json+.*(..) throws java.io.IOException) ||
    execution(com.eclipsesource.json.Json+.new(..) throws java.io.IOException)) && 
   target(object$rac) {
    Throwable cause = rac$e.getCause();
    if(cause instanceof java.io.IOException) {
      throw (java.io.IOException)cause;
    }
    JMLChecker.rethrowUncheckedException(cause);
  }

/** Generated by AspectJML to enable modular signals_only checking (XCS enabled) */
  after(final com.eclipsesource.json.Json object$rac): (execution( * com.eclipsesource.json.Json..*+.*(..))
          || execution(com.eclipsesource.json.Json..*+.new(..))
          || execution( * com.eclipsesource.json.Json+.*(..))
          || execution(com.eclipsesource.json.Json+.new(..))) && 
   this(object$rac) {
   JMLChecker.hasAnyThrownExceptionalPostconditionSignalsOnly();
  }

/** Generated by AspectJML to enhance error reporting (Execution Site enabled) */
  after() throwing (Throwable rac$e): (execution( * com.eclipsesource.json.Json..*+.*(..))
          || execution(com.eclipsesource.json.Json..*+.new(..))
          || execution( * com.eclipsesource.json.Json+.*(..))
          || execution(com.eclipsesource.json.Json+.new(..))){
    JMLChecker.hideAjmlSpecificStackTrace(rac$e);
    JMLChecker.rethrowJMLAssertionError(rac$e);
  }

/** Generated by AspectJML to recover checked exceptions. *
  *  This is based on the exception introduction pattern by Laddad. */
  after(final com.eclipsesource.json.JsonArray object$rac) throwing(JMLInternalRuntimeException rac$e)
    throws java.io.IOException : (execution(* com.eclipsesource.json.JsonArray..*+.*(..) throws java.io.IOException) ||
    execution(com.eclipsesource.json.JsonArray..*+.new(..) throws java.io.IOException) ||
execution(* com.eclipsesource.json.JsonArray+.*(..) throws java.io.IOException) ||
    execution(com.eclipsesource.json.JsonArray+.new(..) throws java.io.IOException)) && 
   target(object$rac) {
    Throwable cause = rac$e.getCause();
    if(cause instanceof java.io.IOException) {
      throw (java.io.IOException)cause;
    }
    JMLChecker.rethrowUncheckedException(cause);
  }

/** Generated by AspectJML to enable modular signals_only checking (XCS enabled) */
  after(final com.eclipsesource.json.JsonArray object$rac): (execution( * com.eclipsesource.json.JsonArray..*+.*(..))
          || execution(com.eclipsesource.json.JsonArray..*+.new(..))
          || execution( * com.eclipsesource.json.JsonArray+.*(..))
          || execution(com.eclipsesource.json.JsonArray+.new(..))) && 
   this(object$rac) {
   JMLChecker.hasAnyThrownExceptionalPostconditionSignalsOnly();
  }

/** Generated by AspectJML to enhance error reporting (Execution Site enabled) */
  after() throwing (Throwable rac$e): (execution( * com.eclipsesource.json.JsonArray..*+.*(..))
          || execution(com.eclipsesource.json.JsonArray..*+.new(..))
          || execution( * com.eclipsesource.json.JsonArray+.*(..))
          || execution(com.eclipsesource.json.JsonArray+.new(..))){
    JMLChecker.hideAjmlSpecificStackTrace(rac$e);
    JMLChecker.rethrowJMLAssertionError(rac$e);
  }

/** Generated by AspectJML to enable modular signals_only checking (XCS enabled) */
  after(final com.eclipsesource.json.JsonHandler object$rac): (execution( * com.eclipsesource.json.JsonHandler..*+.*(..))
          || execution(com.eclipsesource.json.JsonHandler..*+.new(..))
          || execution( * com.eclipsesource.json.JsonHandler+.*(..))
          || execution(com.eclipsesource.json.JsonHandler+.new(..))) && 
   this(object$rac) {
   JMLChecker.hasAnyThrownExceptionalPostconditionSignalsOnly();
  }

/** Generated by AspectJML to enhance error reporting (Execution Site enabled) */
  after() throwing (Throwable rac$e): (execution( * com.eclipsesource.json.JsonHandler..*+.*(..))
          || execution(com.eclipsesource.json.JsonHandler..*+.new(..))
          || execution( * com.eclipsesource.json.JsonHandler+.*(..))
          || execution(com.eclipsesource.json.JsonHandler+.new(..))){
    JMLChecker.hideAjmlSpecificStackTrace(rac$e);
    JMLChecker.rethrowJMLAssertionError(rac$e);
  }

/** Generated by AspectJML to recover checked exceptions. *
  *  This is based on the exception introduction pattern by Laddad. */
  after(final com.eclipsesource.json.JsonLiteral object$rac) throwing(JMLInternalRuntimeException rac$e)
    throws java.io.IOException : (execution(* com.eclipsesource.json.JsonLiteral..*+.*(..) throws java.io.IOException) ||
    execution(com.eclipsesource.json.JsonLiteral..*+.new(..) throws java.io.IOException) ||
execution(* com.eclipsesource.json.JsonLiteral+.*(..) throws java.io.IOException) ||
    execution(com.eclipsesource.json.JsonLiteral+.new(..) throws java.io.IOException)) && 
   target(object$rac) {
    Throwable cause = rac$e.getCause();
    if(cause instanceof java.io.IOException) {
      throw (java.io.IOException)cause;
    }
    JMLChecker.rethrowUncheckedException(cause);
  }

/** Generated by AspectJML to enable modular signals_only checking (XCS enabled) */
  after(final com.eclipsesource.json.JsonLiteral object$rac): (execution( * com.eclipsesource.json.JsonLiteral..*+.*(..))
          || execution(com.eclipsesource.json.JsonLiteral..*+.new(..))
          || execution( * com.eclipsesource.json.JsonLiteral+.*(..))
          || execution(com.eclipsesource.json.JsonLiteral+.new(..))) && 
   this(object$rac) {
   JMLChecker.hasAnyThrownExceptionalPostconditionSignalsOnly();
  }

/** Generated by AspectJML to enhance error reporting (Execution Site enabled) */
  after() throwing (Throwable rac$e): (execution( * com.eclipsesource.json.JsonLiteral..*+.*(..))
          || execution(com.eclipsesource.json.JsonLiteral..*+.new(..))
          || execution( * com.eclipsesource.json.JsonLiteral+.*(..))
          || execution(com.eclipsesource.json.JsonLiteral+.new(..))){
    JMLChecker.hideAjmlSpecificStackTrace(rac$e);
    JMLChecker.rethrowJMLAssertionError(rac$e);
  }

/** Generated by AspectJML to recover checked exceptions. *
  *  This is based on the exception introduction pattern by Laddad. */
  after(final com.eclipsesource.json.JsonNumber object$rac) throwing(JMLInternalRuntimeException rac$e)
    throws java.io.IOException : (execution(* com.eclipsesource.json.JsonNumber..*+.*(..) throws java.io.IOException) ||
    execution(com.eclipsesource.json.JsonNumber..*+.new(..) throws java.io.IOException) ||
execution(* com.eclipsesource.json.JsonNumber+.*(..) throws java.io.IOException) ||
    execution(com.eclipsesource.json.JsonNumber+.new(..) throws java.io.IOException)) && 
   target(object$rac) {
    Throwable cause = rac$e.getCause();
    if(cause instanceof java.io.IOException) {
      throw (java.io.IOException)cause;
    }
    JMLChecker.rethrowUncheckedException(cause);
  }

/** Generated by AspectJML to enable modular signals_only checking (XCS enabled) */
  after(final com.eclipsesource.json.JsonNumber object$rac): (execution( * com.eclipsesource.json.JsonNumber..*+.*(..))
          || execution(com.eclipsesource.json.JsonNumber..*+.new(..))
          || execution( * com.eclipsesource.json.JsonNumber+.*(..))
          || execution(com.eclipsesource.json.JsonNumber+.new(..))) && 
   this(object$rac) {
   JMLChecker.hasAnyThrownExceptionalPostconditionSignalsOnly();
  }

/** Generated by AspectJML to enhance error reporting (Execution Site enabled) */
  after() throwing (Throwable rac$e): (execution( * com.eclipsesource.json.JsonNumber..*+.*(..))
          || execution(com.eclipsesource.json.JsonNumber..*+.new(..))
          || execution( * com.eclipsesource.json.JsonNumber+.*(..))
          || execution(com.eclipsesource.json.JsonNumber+.new(..))){
    JMLChecker.hideAjmlSpecificStackTrace(rac$e);
    JMLChecker.rethrowJMLAssertionError(rac$e);
  }

/** Generated by AspectJML to recover checked exceptions. *
  *  This is based on the exception introduction pattern by Laddad. */
  after(final com.eclipsesource.json.JsonObject object$rac) throwing(JMLInternalRuntimeException rac$e)
    throws java.io.IOException : (execution(* com.eclipsesource.json.JsonObject..*+.*(..) throws java.io.IOException) ||
    execution(com.eclipsesource.json.JsonObject..*+.new(..) throws java.io.IOException) ||
execution(* com.eclipsesource.json.JsonObject+.*(..) throws java.io.IOException) ||
    execution(com.eclipsesource.json.JsonObject+.new(..) throws java.io.IOException)) && 
   target(object$rac) {
    Throwable cause = rac$e.getCause();
    if(cause instanceof java.io.IOException) {
      throw (java.io.IOException)cause;
    }
    JMLChecker.rethrowUncheckedException(cause);
  }

/** Generated by AspectJML to enable modular signals_only checking (XCS enabled) */
  after(final com.eclipsesource.json.JsonObject object$rac): (execution( * com.eclipsesource.json.JsonObject..*+.*(..))
          || execution(com.eclipsesource.json.JsonObject..*+.new(..))
          || execution( * com.eclipsesource.json.JsonObject+.*(..))
          || execution(com.eclipsesource.json.JsonObject+.new(..))) && 
   this(object$rac) {
   JMLChecker.hasAnyThrownExceptionalPostconditionSignalsOnly();
  }

/** Generated by AspectJML to enhance error reporting (Execution Site enabled) */
  after() throwing (Throwable rac$e): (execution( * com.eclipsesource.json.JsonObject..*+.*(..))
          || execution(com.eclipsesource.json.JsonObject..*+.new(..))
          || execution( * com.eclipsesource.json.JsonObject+.*(..))
          || execution(com.eclipsesource.json.JsonObject+.new(..))){
    JMLChecker.hideAjmlSpecificStackTrace(rac$e);
    JMLChecker.rethrowJMLAssertionError(rac$e);
  }

/** Generated by AspectJML to recover checked exceptions. *
  *  This is based on the exception introduction pattern by Laddad. */
  after(final com.eclipsesource.json.JsonParser object$rac) throwing(JMLInternalRuntimeException rac$e)
    throws java.io.IOException : (execution(* com.eclipsesource.json.JsonParser..*+.*(..) throws java.io.IOException) ||
    execution(com.eclipsesource.json.JsonParser..*+.new(..) throws java.io.IOException) ||
execution(* com.eclipsesource.json.JsonParser+.*(..) throws java.io.IOException) ||
    execution(com.eclipsesource.json.JsonParser+.new(..) throws java.io.IOException)) && 
   target(object$rac) {
    Throwable cause = rac$e.getCause();
    if(cause instanceof java.io.IOException) {
      throw (java.io.IOException)cause;
    }
    JMLChecker.rethrowUncheckedException(cause);
  }

/** Generated by AspectJML to enable modular signals_only checking (XCS enabled) */
  after(final com.eclipsesource.json.JsonParser object$rac): (execution( * com.eclipsesource.json.JsonParser..*+.*(..))
          || execution(com.eclipsesource.json.JsonParser..*+.new(..))
          || execution( * com.eclipsesource.json.JsonParser+.*(..))
          || execution(com.eclipsesource.json.JsonParser+.new(..))) && 
   this(object$rac) {
   JMLChecker.hasAnyThrownExceptionalPostconditionSignalsOnly();
  }

/** Generated by AspectJML to enhance error reporting (Execution Site enabled) */
  after() throwing (Throwable rac$e): (execution( * com.eclipsesource.json.JsonParser..*+.*(..))
          || execution(com.eclipsesource.json.JsonParser..*+.new(..))
          || execution( * com.eclipsesource.json.JsonParser+.*(..))
          || execution(com.eclipsesource.json.JsonParser+.new(..))){
    JMLChecker.hideAjmlSpecificStackTrace(rac$e);
    JMLChecker.rethrowJMLAssertionError(rac$e);
  }

/** Generated by AspectJML to recover checked exceptions. *
  *  This is based on the exception introduction pattern by Laddad. */
  after(final com.eclipsesource.json.JsonString object$rac) throwing(JMLInternalRuntimeException rac$e)
    throws java.io.IOException : (execution(* com.eclipsesource.json.JsonString..*+.*(..) throws java.io.IOException) ||
    execution(com.eclipsesource.json.JsonString..*+.new(..) throws java.io.IOException) ||
execution(* com.eclipsesource.json.JsonString+.*(..) throws java.io.IOException) ||
    execution(com.eclipsesource.json.JsonString+.new(..) throws java.io.IOException)) && 
   target(object$rac) {
    Throwable cause = rac$e.getCause();
    if(cause instanceof java.io.IOException) {
      throw (java.io.IOException)cause;
    }
    JMLChecker.rethrowUncheckedException(cause);
  }

/** Generated by AspectJML to enable modular signals_only checking (XCS enabled) */
  after(final com.eclipsesource.json.JsonString object$rac): (execution( * com.eclipsesource.json.JsonString..*+.*(..))
          || execution(com.eclipsesource.json.JsonString..*+.new(..))
          || execution( * com.eclipsesource.json.JsonString+.*(..))
          || execution(com.eclipsesource.json.JsonString+.new(..))) && 
   this(object$rac) {
   JMLChecker.hasAnyThrownExceptionalPostconditionSignalsOnly();
  }

/** Generated by AspectJML to enhance error reporting (Execution Site enabled) */
  after() throwing (Throwable rac$e): (execution( * com.eclipsesource.json.JsonString..*+.*(..))
          || execution(com.eclipsesource.json.JsonString..*+.new(..))
          || execution( * com.eclipsesource.json.JsonString+.*(..))
          || execution(com.eclipsesource.json.JsonString+.new(..))){
    JMLChecker.hideAjmlSpecificStackTrace(rac$e);
    JMLChecker.rethrowJMLAssertionError(rac$e);
  }

/** Generated by AspectJML to recover checked exceptions. *
  *  This is based on the exception introduction pattern by Laddad. */
  after(final com.eclipsesource.json.JsonValue object$rac) throwing(JMLInternalRuntimeException rac$e)
    throws java.io.IOException : (execution(* com.eclipsesource.json.JsonValue..*+.*(..) throws java.io.IOException) ||
    execution(com.eclipsesource.json.JsonValue..*+.new(..) throws java.io.IOException) ||
execution(* com.eclipsesource.json.JsonValue+.*(..) throws java.io.IOException) ||
    execution(com.eclipsesource.json.JsonValue+.new(..) throws java.io.IOException)) && 
   target(object$rac) {
    Throwable cause = rac$e.getCause();
    if(cause instanceof java.io.IOException) {
      throw (java.io.IOException)cause;
    }
    JMLChecker.rethrowUncheckedException(cause);
  }

/** Generated by AspectJML to enable modular signals_only checking (XCS enabled) */
  after(final com.eclipsesource.json.JsonValue object$rac): (execution( * com.eclipsesource.json.JsonValue..*+.*(..))
          || execution(com.eclipsesource.json.JsonValue..*+.new(..))
          || execution( * com.eclipsesource.json.JsonValue+.*(..))
          || execution(com.eclipsesource.json.JsonValue+.new(..))) && 
   this(object$rac) {
   JMLChecker.hasAnyThrownExceptionalPostconditionSignalsOnly();
  }

/** Generated by AspectJML to enhance error reporting (Execution Site enabled) */
  after() throwing (Throwable rac$e): (execution( * com.eclipsesource.json.JsonValue..*+.*(..))
          || execution(com.eclipsesource.json.JsonValue..*+.new(..))
          || execution( * com.eclipsesource.json.JsonValue+.*(..))
          || execution(com.eclipsesource.json.JsonValue+.new(..))){
    JMLChecker.hideAjmlSpecificStackTrace(rac$e);
    JMLChecker.rethrowJMLAssertionError(rac$e);
  }

/** Generated by AspectJML to recover checked exceptions. *
  *  This is based on the exception introduction pattern by Laddad. */
  after(final com.eclipsesource.json.JsonWriter object$rac) throwing(JMLInternalRuntimeException rac$e)
    throws java.io.IOException : (execution(* com.eclipsesource.json.JsonWriter..*+.*(..) throws java.io.IOException) ||
    execution(com.eclipsesource.json.JsonWriter..*+.new(..) throws java.io.IOException) ||
execution(* com.eclipsesource.json.JsonWriter+.*(..) throws java.io.IOException) ||
    execution(com.eclipsesource.json.JsonWriter+.new(..) throws java.io.IOException)) && 
   target(object$rac) {
    Throwable cause = rac$e.getCause();
    if(cause instanceof java.io.IOException) {
      throw (java.io.IOException)cause;
    }
    JMLChecker.rethrowUncheckedException(cause);
  }

/** Generated by AspectJML to enable modular signals_only checking (XCS enabled) */
  after(final com.eclipsesource.json.JsonWriter object$rac): (execution( * com.eclipsesource.json.JsonWriter..*+.*(..))
          || execution(com.eclipsesource.json.JsonWriter..*+.new(..))
          || execution( * com.eclipsesource.json.JsonWriter+.*(..))
          || execution(com.eclipsesource.json.JsonWriter+.new(..))) && 
   this(object$rac) {
   JMLChecker.hasAnyThrownExceptionalPostconditionSignalsOnly();
  }

/** Generated by AspectJML to enhance error reporting (Execution Site enabled) */
  after() throwing (Throwable rac$e): (execution( * com.eclipsesource.json.JsonWriter..*+.*(..))
          || execution(com.eclipsesource.json.JsonWriter..*+.new(..))
          || execution( * com.eclipsesource.json.JsonWriter+.*(..))
          || execution(com.eclipsesource.json.JsonWriter+.new(..))){
    JMLChecker.hideAjmlSpecificStackTrace(rac$e);
    JMLChecker.rethrowJMLAssertionError(rac$e);
  }

/** Generated by AspectJML to enable modular signals_only checking (XCS enabled) */
  after(final com.eclipsesource.json.Location object$rac): (execution( * com.eclipsesource.json.Location..*+.*(..))
          || execution(com.eclipsesource.json.Location..*+.new(..))
          || execution( * com.eclipsesource.json.Location+.*(..))
          || execution(com.eclipsesource.json.Location+.new(..))) && 
   this(object$rac) {
   JMLChecker.hasAnyThrownExceptionalPostconditionSignalsOnly();
  }

/** Generated by AspectJML to enhance error reporting (Execution Site enabled) */
  after() throwing (Throwable rac$e): (execution( * com.eclipsesource.json.Location..*+.*(..))
          || execution(com.eclipsesource.json.Location..*+.new(..))
          || execution( * com.eclipsesource.json.Location+.*(..))
          || execution(com.eclipsesource.json.Location+.new(..))){
    JMLChecker.hideAjmlSpecificStackTrace(rac$e);
    JMLChecker.rethrowJMLAssertionError(rac$e);
  }

/** Generated by AspectJML to enable modular signals_only checking (XCS enabled) */
  after(final com.eclipsesource.json.ParseException object$rac): (execution( * com.eclipsesource.json.ParseException..*+.*(..))
          || execution(com.eclipsesource.json.ParseException..*+.new(..))
          || execution( * com.eclipsesource.json.ParseException+.*(..))
          || execution(com.eclipsesource.json.ParseException+.new(..))) && 
   this(object$rac) {
   JMLChecker.hasAnyThrownExceptionalPostconditionSignalsOnly();
  }

/** Generated by AspectJML to enhance error reporting (Execution Site enabled) */
  after() throwing (Throwable rac$e): (execution( * com.eclipsesource.json.ParseException..*+.*(..))
          || execution(com.eclipsesource.json.ParseException..*+.new(..))
          || execution( * com.eclipsesource.json.ParseException+.*(..))
          || execution(com.eclipsesource.json.ParseException+.new(..))){
    JMLChecker.hideAjmlSpecificStackTrace(rac$e);
    JMLChecker.rethrowJMLAssertionError(rac$e);
  }

/** Generated by AspectJML to recover checked exceptions. *
  *  This is based on the exception introduction pattern by Laddad. */
  after(final com.eclipsesource.json.PrettyPrint object$rac) throwing(JMLInternalRuntimeException rac$e)
    throws java.io.IOException : (execution(* com.eclipsesource.json.PrettyPrint..*+.*(..) throws java.io.IOException) ||
    execution(com.eclipsesource.json.PrettyPrint..*+.new(..) throws java.io.IOException) ||
execution(* com.eclipsesource.json.PrettyPrint+.*(..) throws java.io.IOException) ||
    execution(com.eclipsesource.json.PrettyPrint+.new(..) throws java.io.IOException)) && 
   target(object$rac) {
    Throwable cause = rac$e.getCause();
    if(cause instanceof java.io.IOException) {
      throw (java.io.IOException)cause;
    }
    JMLChecker.rethrowUncheckedException(cause);
  }

/** Generated by AspectJML to enable modular signals_only checking (XCS enabled) */
  after(final com.eclipsesource.json.PrettyPrint object$rac): (execution( * com.eclipsesource.json.PrettyPrint..*+.*(..))
          || execution(com.eclipsesource.json.PrettyPrint..*+.new(..))
          || execution( * com.eclipsesource.json.PrettyPrint+.*(..))
          || execution(com.eclipsesource.json.PrettyPrint+.new(..))) && 
   this(object$rac) {
   JMLChecker.hasAnyThrownExceptionalPostconditionSignalsOnly();
  }

/** Generated by AspectJML to enhance error reporting (Execution Site enabled) */
  after() throwing (Throwable rac$e): (execution( * com.eclipsesource.json.PrettyPrint..*+.*(..))
          || execution(com.eclipsesource.json.PrettyPrint..*+.new(..))
          || execution( * com.eclipsesource.json.PrettyPrint+.*(..))
          || execution(com.eclipsesource.json.PrettyPrint+.new(..))){
    JMLChecker.hideAjmlSpecificStackTrace(rac$e);
    JMLChecker.rethrowJMLAssertionError(rac$e);
  }

/** Generated by AspectJML to enable modular signals_only checking (XCS enabled) */
  after(final com.eclipsesource.json.WriterConfig object$rac): (execution( * com.eclipsesource.json.WriterConfig..*+.*(..))
          || execution(com.eclipsesource.json.WriterConfig..*+.new(..))
          || execution( * com.eclipsesource.json.WriterConfig+.*(..))
          || execution(com.eclipsesource.json.WriterConfig+.new(..))) && 
   this(object$rac) {
   JMLChecker.hasAnyThrownExceptionalPostconditionSignalsOnly();
  }

/** Generated by AspectJML to enhance error reporting (Execution Site enabled) */
  after() throwing (Throwable rac$e): (execution( * com.eclipsesource.json.WriterConfig..*+.*(..))
          || execution(com.eclipsesource.json.WriterConfig..*+.new(..))
          || execution( * com.eclipsesource.json.WriterConfig+.*(..))
          || execution(com.eclipsesource.json.WriterConfig+.new(..))){
    JMLChecker.hideAjmlSpecificStackTrace(rac$e);
    JMLChecker.rethrowJMLAssertionError(rac$e);
  }

/** Generated by AspectJML to recover checked exceptions. *
  *  This is based on the exception introduction pattern by Laddad. */
  after(final com.eclipsesource.json.WritingBuffer object$rac) throwing(JMLInternalRuntimeException rac$e)
    throws java.io.IOException : (execution(* com.eclipsesource.json.WritingBuffer..*+.*(..) throws java.io.IOException) ||
    execution(com.eclipsesource.json.WritingBuffer..*+.new(..) throws java.io.IOException) ||
execution(* com.eclipsesource.json.WritingBuffer+.*(..) throws java.io.IOException) ||
    execution(com.eclipsesource.json.WritingBuffer+.new(..) throws java.io.IOException)) && 
   target(object$rac) {
    Throwable cause = rac$e.getCause();
    if(cause instanceof java.io.IOException) {
      throw (java.io.IOException)cause;
    }
    JMLChecker.rethrowUncheckedException(cause);
  }

/** Generated by AspectJML to enable modular signals_only checking (XCS enabled) */
  after(final com.eclipsesource.json.WritingBuffer object$rac): (execution( * com.eclipsesource.json.WritingBuffer..*+.*(..))
          || execution(com.eclipsesource.json.WritingBuffer..*+.new(..))
          || execution( * com.eclipsesource.json.WritingBuffer+.*(..))
          || execution(com.eclipsesource.json.WritingBuffer+.new(..))) && 
   this(object$rac) {
   JMLChecker.hasAnyThrownExceptionalPostconditionSignalsOnly();
  }

/** Generated by AspectJML to enhance error reporting (Execution Site enabled) */
  after() throwing (Throwable rac$e): (execution( * com.eclipsesource.json.WritingBuffer..*+.*(..))
          || execution(com.eclipsesource.json.WritingBuffer..*+.new(..))
          || execution( * com.eclipsesource.json.WritingBuffer+.*(..))
          || execution(com.eclipsesource.json.WritingBuffer+.new(..))){
    JMLChecker.hideAjmlSpecificStackTrace(rac$e);
    JMLChecker.rethrowJMLAssertionError(rac$e);
  }

/** Generated by AspectJML to enable modular signals_only checking (XCS enabled) */
  after(final datamanagment.DataBasketManager object$rac): (execution( * datamanagment.DataBasketManager..*+.*(..))
          || execution(datamanagment.DataBasketManager..*+.new(..))
          || execution( * datamanagment.DataBasketManager+.*(..))
          || execution(datamanagment.DataBasketManager+.new(..))) && 
   this(object$rac) {
   JMLChecker.hasAnyThrownExceptionalPostconditionSignalsOnly();
  }

/** Generated by AspectJML to enhance error reporting (Execution Site enabled) */
  after() throwing (Throwable rac$e): (execution( * datamanagment.DataBasketManager..*+.*(..))
          || execution(datamanagment.DataBasketManager..*+.new(..))
          || execution( * datamanagment.DataBasketManager+.*(..))
          || execution(datamanagment.DataBasketManager+.new(..))){
    JMLChecker.hideAjmlSpecificStackTrace(rac$e);
    JMLChecker.rethrowJMLAssertionError(rac$e);
  }

public static aspect UtilPreconditionChecking_DataBasketManager$1f5c5f72_666c_4f96_860a_818009da2b0c{
  before(): (execution( * datamanagment.DataBasketManager..*+.*(..))
          || execution(datamanagment.DataBasketManager..*+.new(..))
          || execution( * datamanagment.DataBasketManager+.*(..))
          || execution(datamanagment.DataBasketManager+.new(..))){
    JMLChecker.hasAnyThrownPrecondition();
  }
}

/** Generated by AspectJML to recover checked exceptions. *
  *  This is based on the exception introduction pattern by Laddad. */
  after(final datamanagment.DataIOUtil object$rac) throwing(JMLInternalRuntimeException rac$e)
    throws java.io.IOException : (execution(* datamanagment.DataIOUtil..*+.*(..) throws java.io.IOException) ||
    execution(datamanagment.DataIOUtil..*+.new(..) throws java.io.IOException) ||
execution(* datamanagment.DataIOUtil+.*(..) throws java.io.IOException) ||
    execution(datamanagment.DataIOUtil+.new(..) throws java.io.IOException)) && 
   target(object$rac) {
    Throwable cause = rac$e.getCause();
    if(cause instanceof java.io.IOException) {
      throw (java.io.IOException)cause;
    }
    JMLChecker.rethrowUncheckedException(cause);
  }

/** Generated by AspectJML to enable modular signals_only checking (XCS enabled) */
  after(final datamanagment.DataIOUtil object$rac): (execution( * datamanagment.DataIOUtil..*+.*(..))
          || execution(datamanagment.DataIOUtil..*+.new(..))
          || execution( * datamanagment.DataIOUtil+.*(..))
          || execution(datamanagment.DataIOUtil+.new(..))) && 
   this(object$rac) {
   JMLChecker.hasAnyThrownExceptionalPostconditionSignalsOnly();
  }

/** Generated by AspectJML to enhance error reporting (Execution Site enabled) */
  after() throwing (Throwable rac$e): (execution( * datamanagment.DataIOUtil..*+.*(..))
          || execution(datamanagment.DataIOUtil..*+.new(..))
          || execution( * datamanagment.DataIOUtil+.*(..))
          || execution(datamanagment.DataIOUtil+.new(..))){
    JMLChecker.hideAjmlSpecificStackTrace(rac$e);
    JMLChecker.rethrowJMLAssertionError(rac$e);
  }

/** Generated by AspectJML to recover checked exceptions. *
  *  This is based on the exception introduction pattern by Laddad. */
  after(final datamanagment.DataStoreManager object$rac) throwing(JMLInternalRuntimeException rac$e)
    throws java.io.IOException : (execution(* datamanagment.DataStoreManager..*+.*(..) throws java.io.IOException) ||
    execution(datamanagment.DataStoreManager..*+.new(..) throws java.io.IOException) ||
execution(* datamanagment.DataStoreManager+.*(..) throws java.io.IOException) ||
    execution(datamanagment.DataStoreManager+.new(..) throws java.io.IOException)) && 
   target(object$rac) {
    Throwable cause = rac$e.getCause();
    if(cause instanceof java.io.IOException) {
      throw (java.io.IOException)cause;
    }
    JMLChecker.rethrowUncheckedException(cause);
  }
  after(final datamanagment.DataStoreManager object$rac) throwing(JMLInternalRuntimeException rac$e)
    throws exceptions.NotLoggedInException : (execution(* datamanagment.DataStoreManager..*+.*(..) throws exceptions.NotLoggedInException) ||
    execution(datamanagment.DataStoreManager..*+.new(..) throws exceptions.NotLoggedInException) ||
execution(* datamanagment.DataStoreManager+.*(..) throws exceptions.NotLoggedInException) ||
    execution(datamanagment.DataStoreManager+.new(..) throws exceptions.NotLoggedInException)) && 
   target(object$rac) {
    Throwable cause = rac$e.getCause();
    if(cause instanceof exceptions.NotLoggedInException) {
      throw (exceptions.NotLoggedInException)cause;
    }
    JMLChecker.rethrowUncheckedException(cause);
  }
  after(final datamanagment.DataStoreManager object$rac) throwing(JMLInternalRuntimeException rac$e)
    throws exceptions.NonExistentProductId : (execution(* datamanagment.DataStoreManager..*+.*(..) throws exceptions.NonExistentProductId) ||
    execution(datamanagment.DataStoreManager..*+.new(..) throws exceptions.NonExistentProductId) ||
execution(* datamanagment.DataStoreManager+.*(..) throws exceptions.NonExistentProductId) ||
    execution(datamanagment.DataStoreManager+.new(..) throws exceptions.NonExistentProductId)) && 
   target(object$rac) {
    Throwable cause = rac$e.getCause();
    if(cause instanceof exceptions.NonExistentProductId) {
      throw (exceptions.NonExistentProductId)cause;
    }
    JMLChecker.rethrowUncheckedException(cause);
  }

/** Generated by AspectJML to enable modular signals_only checking (XCS enabled) */
  after(final datamanagment.DataStoreManager object$rac): (execution( * datamanagment.DataStoreManager..*+.*(..))
          || execution(datamanagment.DataStoreManager..*+.new(..))
          || execution( * datamanagment.DataStoreManager+.*(..))
          || execution(datamanagment.DataStoreManager+.new(..))) && 
   this(object$rac) {
   JMLChecker.hasAnyThrownExceptionalPostconditionSignalsOnly();
  }

/** Generated by AspectJML to enhance error reporting (Execution Site enabled) */
  after() throwing (Throwable rac$e): (execution( * datamanagment.DataStoreManager..*+.*(..))
          || execution(datamanagment.DataStoreManager..*+.new(..))
          || execution( * datamanagment.DataStoreManager+.*(..))
          || execution(datamanagment.DataStoreManager+.new(..))){
    JMLChecker.hideAjmlSpecificStackTrace(rac$e);
    JMLChecker.rethrowJMLAssertionError(rac$e);
  }

public static aspect UtilPreconditionChecking_DataStoreManager$5437655d_7edb_4d50_91a1_13a189e3f750{
  before(): (execution( * datamanagment.DataStoreManager..*+.*(..))
          || execution(datamanagment.DataStoreManager..*+.new(..))
          || execution( * datamanagment.DataStoreManager+.*(..))
          || execution(datamanagment.DataStoreManager+.new(..))){
    JMLChecker.hasAnyThrownPrecondition();
  }
}

/** Generated by AspectJML to enable modular signals_only checking (XCS enabled) */
  after(final dataobjects.DataObject object$rac): (execution( * dataobjects.DataObject..*+.*(..))
          || execution(dataobjects.DataObject..*+.new(..))
          || execution( * dataobjects.DataObject+.*(..))
          || execution(dataobjects.DataObject+.new(..))) && 
   this(object$rac) {
   JMLChecker.hasAnyThrownExceptionalPostconditionSignalsOnly();
  }

/** Generated by AspectJML to enhance error reporting (Execution Site enabled) */
  after() throwing (Throwable rac$e): (execution( * dataobjects.DataObject..*+.*(..))
          || execution(dataobjects.DataObject..*+.new(..))
          || execution( * dataobjects.DataObject+.*(..))
          || execution(dataobjects.DataObject+.new(..))){
    JMLChecker.hideAjmlSpecificStackTrace(rac$e);
    JMLChecker.rethrowJMLAssertionError(rac$e);
  }

/** Generated by AspectJML to enable modular signals_only checking (XCS enabled) */
  after(final dataobjects.Product object$rac): (execution( * dataobjects.Product..*+.*(..))
          || execution(dataobjects.Product..*+.new(..))
          || execution( * dataobjects.Product+.*(..))
          || execution(dataobjects.Product+.new(..))) && 
   this(object$rac) {
   JMLChecker.hasAnyThrownExceptionalPostconditionSignalsOnly();
  }

/** Generated by AspectJML to enhance error reporting (Execution Site enabled) */
  after() throwing (Throwable rac$e): (execution( * dataobjects.Product..*+.*(..))
          || execution(dataobjects.Product..*+.new(..))
          || execution( * dataobjects.Product+.*(..))
          || execution(dataobjects.Product+.new(..))){
    JMLChecker.hideAjmlSpecificStackTrace(rac$e);
    JMLChecker.rethrowJMLAssertionError(rac$e);
  }

public static aspect UtilPreconditionChecking_Product$5cb705df_ad18_4e74_a2a2_95cc9b9e01c9{
  before(): (execution( * dataobjects.Product..*+.*(..))
          || execution(dataobjects.Product..*+.new(..))
          || execution( * dataobjects.Product+.*(..))
          || execution(dataobjects.Product+.new(..))){
    JMLChecker.hasAnyThrownPrecondition();
  }
}

/** Generated by AspectJML to enable modular signals_only checking (XCS enabled) */
  after(final dataobjects.User object$rac): (execution( * dataobjects.User..*+.*(..))
          || execution(dataobjects.User..*+.new(..))
          || execution( * dataobjects.User+.*(..))
          || execution(dataobjects.User+.new(..))) && 
   this(object$rac) {
   JMLChecker.hasAnyThrownExceptionalPostconditionSignalsOnly();
  }

/** Generated by AspectJML to enhance error reporting (Execution Site enabled) */
  after() throwing (Throwable rac$e): (execution( * dataobjects.User..*+.*(..))
          || execution(dataobjects.User..*+.new(..))
          || execution( * dataobjects.User+.*(..))
          || execution(dataobjects.User+.new(..))){
    JMLChecker.hideAjmlSpecificStackTrace(rac$e);
    JMLChecker.rethrowJMLAssertionError(rac$e);
  }

public static aspect UtilPreconditionChecking_User$6b59ec02_cce1_46fa_8781_13ad1cae91b4{
  before(): (execution( * dataobjects.User..*+.*(..))
          || execution(dataobjects.User..*+.new(..))
          || execution( * dataobjects.User+.*(..))
          || execution(dataobjects.User+.new(..))){
    JMLChecker.hasAnyThrownPrecondition();
  }
}

/** Generated by AspectJML to enable modular signals_only checking (XCS enabled) */
  after(final exceptions.AlreadyLoggedIn object$rac): (execution( * exceptions.AlreadyLoggedIn..*+.*(..))
          || execution(exceptions.AlreadyLoggedIn..*+.new(..))
          || execution( * exceptions.AlreadyLoggedIn+.*(..))
          || execution(exceptions.AlreadyLoggedIn+.new(..))) && 
   this(object$rac) {
   JMLChecker.hasAnyThrownExceptionalPostconditionSignalsOnly();
  }

/** Generated by AspectJML to enhance error reporting (Execution Site enabled) */
  after() throwing (Throwable rac$e): (execution( * exceptions.AlreadyLoggedIn..*+.*(..))
          || execution(exceptions.AlreadyLoggedIn..*+.new(..))
          || execution( * exceptions.AlreadyLoggedIn+.*(..))
          || execution(exceptions.AlreadyLoggedIn+.new(..))){
    JMLChecker.hideAjmlSpecificStackTrace(rac$e);
    JMLChecker.rethrowJMLAssertionError(rac$e);
  }

/** Generated by AspectJML to enable modular signals_only checking (XCS enabled) */
  after(final exceptions.EmailIsAlreadyUsed object$rac): (execution( * exceptions.EmailIsAlreadyUsed..*+.*(..))
          || execution(exceptions.EmailIsAlreadyUsed..*+.new(..))
          || execution( * exceptions.EmailIsAlreadyUsed+.*(..))
          || execution(exceptions.EmailIsAlreadyUsed+.new(..))) && 
   this(object$rac) {
   JMLChecker.hasAnyThrownExceptionalPostconditionSignalsOnly();
  }

/** Generated by AspectJML to enhance error reporting (Execution Site enabled) */
  after() throwing (Throwable rac$e): (execution( * exceptions.EmailIsAlreadyUsed..*+.*(..))
          || execution(exceptions.EmailIsAlreadyUsed..*+.new(..))
          || execution( * exceptions.EmailIsAlreadyUsed+.*(..))
          || execution(exceptions.EmailIsAlreadyUsed+.new(..))){
    JMLChecker.hideAjmlSpecificStackTrace(rac$e);
    JMLChecker.rethrowJMLAssertionError(rac$e);
  }

/** Generated by AspectJML to enable modular signals_only checking (XCS enabled) */
  after(final exceptions.EmptyProductsList object$rac): (execution( * exceptions.EmptyProductsList..*+.*(..))
          || execution(exceptions.EmptyProductsList..*+.new(..))
          || execution( * exceptions.EmptyProductsList+.*(..))
          || execution(exceptions.EmptyProductsList+.new(..))) && 
   this(object$rac) {
   JMLChecker.hasAnyThrownExceptionalPostconditionSignalsOnly();
  }

/** Generated by AspectJML to enhance error reporting (Execution Site enabled) */
  after() throwing (Throwable rac$e): (execution( * exceptions.EmptyProductsList..*+.*(..))
          || execution(exceptions.EmptyProductsList..*+.new(..))
          || execution( * exceptions.EmptyProductsList+.*(..))
          || execution(exceptions.EmptyProductsList+.new(..))){
    JMLChecker.hideAjmlSpecificStackTrace(rac$e);
    JMLChecker.rethrowJMLAssertionError(rac$e);
  }

/** Generated by AspectJML to enable modular signals_only checking (XCS enabled) */
  after(final exceptions.EmptyUsersList object$rac): (execution( * exceptions.EmptyUsersList..*+.*(..))
          || execution(exceptions.EmptyUsersList..*+.new(..))
          || execution( * exceptions.EmptyUsersList+.*(..))
          || execution(exceptions.EmptyUsersList+.new(..))) && 
   this(object$rac) {
   JMLChecker.hasAnyThrownExceptionalPostconditionSignalsOnly();
  }

/** Generated by AspectJML to enhance error reporting (Execution Site enabled) */
  after() throwing (Throwable rac$e): (execution( * exceptions.EmptyUsersList..*+.*(..))
          || execution(exceptions.EmptyUsersList..*+.new(..))
          || execution( * exceptions.EmptyUsersList+.*(..))
          || execution(exceptions.EmptyUsersList+.new(..))){
    JMLChecker.hideAjmlSpecificStackTrace(rac$e);
    JMLChecker.rethrowJMLAssertionError(rac$e);
  }

/** Generated by AspectJML to enable modular signals_only checking (XCS enabled) */
  after(final exceptions.NonExistentProductId object$rac): (execution( * exceptions.NonExistentProductId..*+.*(..))
          || execution(exceptions.NonExistentProductId..*+.new(..))
          || execution( * exceptions.NonExistentProductId+.*(..))
          || execution(exceptions.NonExistentProductId+.new(..))) && 
   this(object$rac) {
   JMLChecker.hasAnyThrownExceptionalPostconditionSignalsOnly();
  }

/** Generated by AspectJML to enhance error reporting (Execution Site enabled) */
  after() throwing (Throwable rac$e): (execution( * exceptions.NonExistentProductId..*+.*(..))
          || execution(exceptions.NonExistentProductId..*+.new(..))
          || execution( * exceptions.NonExistentProductId+.*(..))
          || execution(exceptions.NonExistentProductId+.new(..))){
    JMLChecker.hideAjmlSpecificStackTrace(rac$e);
    JMLChecker.rethrowJMLAssertionError(rac$e);
  }

/** Generated by AspectJML to enable modular signals_only checking (XCS enabled) */
  after(final exceptions.NotLoggedInException object$rac): (execution( * exceptions.NotLoggedInException..*+.*(..))
          || execution(exceptions.NotLoggedInException..*+.new(..))
          || execution( * exceptions.NotLoggedInException+.*(..))
          || execution(exceptions.NotLoggedInException+.new(..))) && 
   this(object$rac) {
   JMLChecker.hasAnyThrownExceptionalPostconditionSignalsOnly();
  }

/** Generated by AspectJML to enhance error reporting (Execution Site enabled) */
  after() throwing (Throwable rac$e): (execution( * exceptions.NotLoggedInException..*+.*(..))
          || execution(exceptions.NotLoggedInException..*+.new(..))
          || execution( * exceptions.NotLoggedInException+.*(..))
          || execution(exceptions.NotLoggedInException+.new(..))){
    JMLChecker.hideAjmlSpecificStackTrace(rac$e);
    JMLChecker.rethrowJMLAssertionError(rac$e);
  }

/** Generated by AspectJML to enable modular signals_only checking (XCS enabled) */
  after(final inpututils.InputUtil object$rac): (execution( * inpututils.InputUtil..*+.*(..))
          || execution(inpututils.InputUtil..*+.new(..))
          || execution( * inpututils.InputUtil+.*(..))
          || execution(inpututils.InputUtil+.new(..))) && 
   this(object$rac) {
   JMLChecker.hasAnyThrownExceptionalPostconditionSignalsOnly();
  }

/** Generated by AspectJML to enhance error reporting (Execution Site enabled) */
  after() throwing (Throwable rac$e): (execution( * inpututils.InputUtil..*+.*(..))
          || execution(inpututils.InputUtil..*+.new(..))
          || execution( * inpututils.InputUtil+.*(..))
          || execution(inpututils.InputUtil+.new(..))){
    JMLChecker.hideAjmlSpecificStackTrace(rac$e);
    JMLChecker.rethrowJMLAssertionError(rac$e);
  }

/** Generated by AspectJML to recover checked exceptions. *
  *  This is based on the exception introduction pattern by Laddad. */
  after(final menu.AuthenticationMenu object$rac) throwing(JMLInternalRuntimeException rac$e)
    throws java.io.IOException : (execution(* menu.AuthenticationMenu..*+.*(..) throws java.io.IOException) ||
    execution(menu.AuthenticationMenu..*+.new(..) throws java.io.IOException) ||
execution(* menu.AuthenticationMenu+.*(..) throws java.io.IOException) ||
    execution(menu.AuthenticationMenu+.new(..) throws java.io.IOException)) && 
   target(object$rac) {
    Throwable cause = rac$e.getCause();
    if(cause instanceof java.io.IOException) {
      throw (java.io.IOException)cause;
    }
    JMLChecker.rethrowUncheckedException(cause);
  }
  after(final menu.AuthenticationMenu object$rac) throwing(JMLInternalRuntimeException rac$e)
    throws exceptions.NotLoggedInException : (execution(* menu.AuthenticationMenu..*+.*(..) throws exceptions.NotLoggedInException) ||
    execution(menu.AuthenticationMenu..*+.new(..) throws exceptions.NotLoggedInException) ||
execution(* menu.AuthenticationMenu+.*(..) throws exceptions.NotLoggedInException) ||
    execution(menu.AuthenticationMenu+.new(..) throws exceptions.NotLoggedInException)) && 
   target(object$rac) {
    Throwable cause = rac$e.getCause();
    if(cause instanceof exceptions.NotLoggedInException) {
      throw (exceptions.NotLoggedInException)cause;
    }
    JMLChecker.rethrowUncheckedException(cause);
  }
  after(final menu.AuthenticationMenu object$rac) throwing(JMLInternalRuntimeException rac$e)
    throws exceptions.NonExistentProductId : (execution(* menu.AuthenticationMenu..*+.*(..) throws exceptions.NonExistentProductId) ||
    execution(menu.AuthenticationMenu..*+.new(..) throws exceptions.NonExistentProductId) ||
execution(* menu.AuthenticationMenu+.*(..) throws exceptions.NonExistentProductId) ||
    execution(menu.AuthenticationMenu+.new(..) throws exceptions.NonExistentProductId)) && 
   target(object$rac) {
    Throwable cause = rac$e.getCause();
    if(cause instanceof exceptions.NonExistentProductId) {
      throw (exceptions.NonExistentProductId)cause;
    }
    JMLChecker.rethrowUncheckedException(cause);
  }

/** Generated by AspectJML to enable modular signals_only checking (XCS enabled) */
  after(final menu.AuthenticationMenu object$rac): (execution( * menu.AuthenticationMenu..*+.*(..))
          || execution(menu.AuthenticationMenu..*+.new(..))
          || execution( * menu.AuthenticationMenu+.*(..))
          || execution(menu.AuthenticationMenu+.new(..))) && 
   this(object$rac) {
   JMLChecker.hasAnyThrownExceptionalPostconditionSignalsOnly();
  }

/** Generated by AspectJML to enhance error reporting (Execution Site enabled) */
  after() throwing (Throwable rac$e): (execution( * menu.AuthenticationMenu..*+.*(..))
          || execution(menu.AuthenticationMenu..*+.new(..))
          || execution( * menu.AuthenticationMenu+.*(..))
          || execution(menu.AuthenticationMenu+.new(..))){
    JMLChecker.hideAjmlSpecificStackTrace(rac$e);
    JMLChecker.rethrowJMLAssertionError(rac$e);
  }

public static aspect UtilPreconditionChecking_AuthenticationMenu$32e5ae3d_a51d_4c77_90f8_3ca2414daf76{
  before(): (execution( * menu.AuthenticationMenu..*+.*(..))
          || execution(menu.AuthenticationMenu..*+.new(..))
          || execution( * menu.AuthenticationMenu+.*(..))
          || execution(menu.AuthenticationMenu+.new(..))){
    JMLChecker.hasAnyThrownPrecondition();
  }
}

/** Generated by AspectJML to recover checked exceptions. *
  *  This is based on the exception introduction pattern by Laddad. */
  after(final menu.BasketMenu object$rac) throwing(JMLInternalRuntimeException rac$e)
    throws java.io.IOException : (execution(* menu.BasketMenu..*+.*(..) throws java.io.IOException) ||
    execution(menu.BasketMenu..*+.new(..) throws java.io.IOException) ||
execution(* menu.BasketMenu+.*(..) throws java.io.IOException) ||
    execution(menu.BasketMenu+.new(..) throws java.io.IOException)) && 
   target(object$rac) {
    Throwable cause = rac$e.getCause();
    if(cause instanceof java.io.IOException) {
      throw (java.io.IOException)cause;
    }
    JMLChecker.rethrowUncheckedException(cause);
  }

/** Generated by AspectJML to enable modular signals_only checking (XCS enabled) */
  after(final menu.BasketMenu object$rac): (execution( * menu.BasketMenu..*+.*(..))
          || execution(menu.BasketMenu..*+.new(..))
          || execution( * menu.BasketMenu+.*(..))
          || execution(menu.BasketMenu+.new(..))) && 
   this(object$rac) {
   JMLChecker.hasAnyThrownExceptionalPostconditionSignalsOnly();
  }

/** Generated by AspectJML to enhance error reporting (Execution Site enabled) */
  after() throwing (Throwable rac$e): (execution( * menu.BasketMenu..*+.*(..))
          || execution(menu.BasketMenu..*+.new(..))
          || execution( * menu.BasketMenu+.*(..))
          || execution(menu.BasketMenu+.new(..))){
    JMLChecker.hideAjmlSpecificStackTrace(rac$e);
    JMLChecker.rethrowJMLAssertionError(rac$e);
  }

public static aspect UtilPreconditionChecking_BasketMenu$70bf681f_c955_45bc_ada6_d06b111f2d33{
  before(): (execution( * menu.BasketMenu..*+.*(..))
          || execution(menu.BasketMenu..*+.new(..))
          || execution( * menu.BasketMenu+.*(..))
          || execution(menu.BasketMenu+.new(..))){
    JMLChecker.hasAnyThrownPrecondition();
  }
}

/** Generated by AspectJML to recover checked exceptions. *
  *  This is based on the exception introduction pattern by Laddad. */
  after(final menu.DataGenerationMenu object$rac) throwing(JMLInternalRuntimeException rac$e)
    throws java.io.IOException : (execution(* menu.DataGenerationMenu..*+.*(..) throws java.io.IOException) ||
    execution(menu.DataGenerationMenu..*+.new(..) throws java.io.IOException) ||
execution(* menu.DataGenerationMenu+.*(..) throws java.io.IOException) ||
    execution(menu.DataGenerationMenu+.new(..) throws java.io.IOException)) && 
   target(object$rac) {
    Throwable cause = rac$e.getCause();
    if(cause instanceof java.io.IOException) {
      throw (java.io.IOException)cause;
    }
    JMLChecker.rethrowUncheckedException(cause);
  }
  after(final menu.DataGenerationMenu object$rac) throwing(JMLInternalRuntimeException rac$e)
    throws exceptions.NotLoggedInException : (execution(* menu.DataGenerationMenu..*+.*(..) throws exceptions.NotLoggedInException) ||
    execution(menu.DataGenerationMenu..*+.new(..) throws exceptions.NotLoggedInException) ||
execution(* menu.DataGenerationMenu+.*(..) throws exceptions.NotLoggedInException) ||
    execution(menu.DataGenerationMenu+.new(..) throws exceptions.NotLoggedInException)) && 
   target(object$rac) {
    Throwable cause = rac$e.getCause();
    if(cause instanceof exceptions.NotLoggedInException) {
      throw (exceptions.NotLoggedInException)cause;
    }
    JMLChecker.rethrowUncheckedException(cause);
  }
  after(final menu.DataGenerationMenu object$rac) throwing(JMLInternalRuntimeException rac$e)
    throws exceptions.NonExistentProductId : (execution(* menu.DataGenerationMenu..*+.*(..) throws exceptions.NonExistentProductId) ||
    execution(menu.DataGenerationMenu..*+.new(..) throws exceptions.NonExistentProductId) ||
execution(* menu.DataGenerationMenu+.*(..) throws exceptions.NonExistentProductId) ||
    execution(menu.DataGenerationMenu+.new(..) throws exceptions.NonExistentProductId)) && 
   target(object$rac) {
    Throwable cause = rac$e.getCause();
    if(cause instanceof exceptions.NonExistentProductId) {
      throw (exceptions.NonExistentProductId)cause;
    }
    JMLChecker.rethrowUncheckedException(cause);
  }

/** Generated by AspectJML to enable modular signals_only checking (XCS enabled) */
  after(final menu.DataGenerationMenu object$rac): (execution( * menu.DataGenerationMenu..*+.*(..))
          || execution(menu.DataGenerationMenu..*+.new(..))
          || execution( * menu.DataGenerationMenu+.*(..))
          || execution(menu.DataGenerationMenu+.new(..))) && 
   this(object$rac) {
   JMLChecker.hasAnyThrownExceptionalPostconditionSignalsOnly();
  }

/** Generated by AspectJML to enhance error reporting (Execution Site enabled) */
  after() throwing (Throwable rac$e): (execution( * menu.DataGenerationMenu..*+.*(..))
          || execution(menu.DataGenerationMenu..*+.new(..))
          || execution( * menu.DataGenerationMenu+.*(..))
          || execution(menu.DataGenerationMenu+.new(..))){
    JMLChecker.hideAjmlSpecificStackTrace(rac$e);
    JMLChecker.rethrowJMLAssertionError(rac$e);
  }

public static aspect UtilPreconditionChecking_DataGenerationMenu$e984e126_7d7b_4d01_bed1_838236dbf1be{
  before(): (execution( * menu.DataGenerationMenu..*+.*(..))
          || execution(menu.DataGenerationMenu..*+.new(..))
          || execution( * menu.DataGenerationMenu+.*(..))
          || execution(menu.DataGenerationMenu+.new(..))){
    JMLChecker.hasAnyThrownPrecondition();
  }
}

/** Generated by AspectJML to recover checked exceptions. *
  *  This is based on the exception introduction pattern by Laddad. */
  after(final menu.LoginCheck object$rac) throwing(JMLInternalRuntimeException rac$e)
    throws exceptions.NotLoggedInException : (execution(* menu.LoginCheck..*+.*(..) throws exceptions.NotLoggedInException) ||
    execution(menu.LoginCheck..*+.new(..) throws exceptions.NotLoggedInException) ||
execution(* menu.LoginCheck+.*(..) throws exceptions.NotLoggedInException) ||
    execution(menu.LoginCheck+.new(..) throws exceptions.NotLoggedInException)) && 
   target(object$rac) {
    Throwable cause = rac$e.getCause();
    if(cause instanceof exceptions.NotLoggedInException) {
      throw (exceptions.NotLoggedInException)cause;
    }
    JMLChecker.rethrowUncheckedException(cause);
  }

/** Generated by AspectJML to enable modular signals_only checking (XCS enabled) */
  after(final menu.LoginCheck object$rac): (execution( * menu.LoginCheck..*+.*(..))
          || execution(menu.LoginCheck..*+.new(..))
          || execution( * menu.LoginCheck+.*(..))
          || execution(menu.LoginCheck+.new(..))) && 
   this(object$rac) {
   JMLChecker.hasAnyThrownExceptionalPostconditionSignalsOnly();
  }

/** Generated by AspectJML to enhance error reporting (Execution Site enabled) */
  after() throwing (Throwable rac$e): (execution( * menu.LoginCheck..*+.*(..))
          || execution(menu.LoginCheck..*+.new(..))
          || execution( * menu.LoginCheck+.*(..))
          || execution(menu.LoginCheck+.new(..))){
    JMLChecker.hideAjmlSpecificStackTrace(rac$e);
    JMLChecker.rethrowJMLAssertionError(rac$e);
  }

/** Generated by AspectJML to recover checked exceptions. *
  *  This is based on the exception introduction pattern by Laddad. */
  after(final menu.LoginMenu object$rac) throwing(JMLInternalRuntimeException rac$e)
    throws exceptions.NotLoggedInException : (execution(* menu.LoginMenu..*+.*(..) throws exceptions.NotLoggedInException) ||
    execution(menu.LoginMenu..*+.new(..) throws exceptions.NotLoggedInException) ||
execution(* menu.LoginMenu+.*(..) throws exceptions.NotLoggedInException) ||
    execution(menu.LoginMenu+.new(..) throws exceptions.NotLoggedInException)) && 
   target(object$rac) {
    Throwable cause = rac$e.getCause();
    if(cause instanceof exceptions.NotLoggedInException) {
      throw (exceptions.NotLoggedInException)cause;
    }
    JMLChecker.rethrowUncheckedException(cause);
  }
  after(final menu.LoginMenu object$rac) throwing(JMLInternalRuntimeException rac$e)
    throws java.io.IOException : (execution(* menu.LoginMenu..*+.*(..) throws java.io.IOException) ||
    execution(menu.LoginMenu..*+.new(..) throws java.io.IOException) ||
execution(* menu.LoginMenu+.*(..) throws java.io.IOException) ||
    execution(menu.LoginMenu+.new(..) throws java.io.IOException)) && 
   target(object$rac) {
    Throwable cause = rac$e.getCause();
    if(cause instanceof java.io.IOException) {
      throw (java.io.IOException)cause;
    }
    JMLChecker.rethrowUncheckedException(cause);
  }
  after(final menu.LoginMenu object$rac) throwing(JMLInternalRuntimeException rac$e)
    throws exceptions.NonExistentProductId : (execution(* menu.LoginMenu..*+.*(..) throws exceptions.NonExistentProductId) ||
    execution(menu.LoginMenu..*+.new(..) throws exceptions.NonExistentProductId) ||
execution(* menu.LoginMenu+.*(..) throws exceptions.NonExistentProductId) ||
    execution(menu.LoginMenu+.new(..) throws exceptions.NonExistentProductId)) && 
   target(object$rac) {
    Throwable cause = rac$e.getCause();
    if(cause instanceof exceptions.NonExistentProductId) {
      throw (exceptions.NonExistentProductId)cause;
    }
    JMLChecker.rethrowUncheckedException(cause);
  }

/** Generated by AspectJML to enable modular signals_only checking (XCS enabled) */
  after(final menu.LoginMenu object$rac): (execution( * menu.LoginMenu..*+.*(..))
          || execution(menu.LoginMenu..*+.new(..))
          || execution( * menu.LoginMenu+.*(..))
          || execution(menu.LoginMenu+.new(..))) && 
   this(object$rac) {
   JMLChecker.hasAnyThrownExceptionalPostconditionSignalsOnly();
  }

/** Generated by AspectJML to enhance error reporting (Execution Site enabled) */
  after() throwing (Throwable rac$e): (execution( * menu.LoginMenu..*+.*(..))
          || execution(menu.LoginMenu..*+.new(..))
          || execution( * menu.LoginMenu+.*(..))
          || execution(menu.LoginMenu+.new(..))){
    JMLChecker.hideAjmlSpecificStackTrace(rac$e);
    JMLChecker.rethrowJMLAssertionError(rac$e);
  }

public static aspect UtilPreconditionChecking_LoginMenu$09fac3f2_07a5_4c6e_87fe_cbeb816ac6c3{
  before(): (execution( * menu.LoginMenu..*+.*(..))
          || execution(menu.LoginMenu..*+.new(..))
          || execution( * menu.LoginMenu+.*(..))
          || execution(menu.LoginMenu+.new(..))){
    JMLChecker.hasAnyThrownPrecondition();
  }
}

/** Generated by AspectJML to enable modular signals_only checking (XCS enabled) */
  after(final menu.MainMenu object$rac): (execution( * menu.MainMenu..*+.*(..))
          || execution(menu.MainMenu..*+.new(..))
          || execution( * menu.MainMenu+.*(..))
          || execution(menu.MainMenu+.new(..))) && 
   this(object$rac) {
   JMLChecker.hasAnyThrownExceptionalPostconditionSignalsOnly();
  }

/** Generated by AspectJML to enhance error reporting (Execution Site enabled) */
  after() throwing (Throwable rac$e): (execution( * menu.MainMenu..*+.*(..))
          || execution(menu.MainMenu..*+.new(..))
          || execution( * menu.MainMenu+.*(..))
          || execution(menu.MainMenu+.new(..))){
    JMLChecker.hideAjmlSpecificStackTrace(rac$e);
    JMLChecker.rethrowJMLAssertionError(rac$e);
  }

public static aspect UtilPreconditionChecking_MainMenu$5a713f41_63af_4c09_a66a_5c87b168aaaf{
  before(): (execution( * menu.MainMenu..*+.*(..))
          || execution(menu.MainMenu..*+.new(..))
          || execution( * menu.MainMenu+.*(..))
          || execution(menu.MainMenu+.new(..))){
    JMLChecker.hasAnyThrownPrecondition();
  }
}

/** Generated by AspectJML to recover checked exceptions. *
  *  This is based on the exception introduction pattern by Laddad. */
  after(final menu.MenuItem object$rac) throwing(JMLInternalRuntimeException rac$e)
    throws java.io.IOException : (execution(* menu.MenuItem..*+.*(..) throws java.io.IOException) ||
    execution(menu.MenuItem..*+.new(..) throws java.io.IOException) ||
execution(* menu.MenuItem+.*(..) throws java.io.IOException) ||
    execution(menu.MenuItem+.new(..) throws java.io.IOException)) && 
   target(object$rac) {
    Throwable cause = rac$e.getCause();
    if(cause instanceof java.io.IOException) {
      throw (java.io.IOException)cause;
    }
    JMLChecker.rethrowUncheckedException(cause);
  }
  after(final menu.MenuItem object$rac) throwing(JMLInternalRuntimeException rac$e)
    throws exceptions.NotLoggedInException : (execution(* menu.MenuItem..*+.*(..) throws exceptions.NotLoggedInException) ||
    execution(menu.MenuItem..*+.new(..) throws exceptions.NotLoggedInException) ||
execution(* menu.MenuItem+.*(..) throws exceptions.NotLoggedInException) ||
    execution(menu.MenuItem+.new(..) throws exceptions.NotLoggedInException)) && 
   target(object$rac) {
    Throwable cause = rac$e.getCause();
    if(cause instanceof exceptions.NotLoggedInException) {
      throw (exceptions.NotLoggedInException)cause;
    }
    JMLChecker.rethrowUncheckedException(cause);
  }
  after(final menu.MenuItem object$rac) throwing(JMLInternalRuntimeException rac$e)
    throws exceptions.NonExistentProductId : (execution(* menu.MenuItem..*+.*(..) throws exceptions.NonExistentProductId) ||
    execution(menu.MenuItem..*+.new(..) throws exceptions.NonExistentProductId) ||
execution(* menu.MenuItem+.*(..) throws exceptions.NonExistentProductId) ||
    execution(menu.MenuItem+.new(..) throws exceptions.NonExistentProductId)) && 
   target(object$rac) {
    Throwable cause = rac$e.getCause();
    if(cause instanceof exceptions.NonExistentProductId) {
      throw (exceptions.NonExistentProductId)cause;
    }
    JMLChecker.rethrowUncheckedException(cause);
  }

/** Generated by AspectJML to enable modular signals_only checking (XCS enabled) */
  after(final menu.MenuItem object$rac): (execution( * menu.MenuItem..*+.*(..))
          || execution(menu.MenuItem..*+.new(..))
          || execution( * menu.MenuItem+.*(..))
          || execution(menu.MenuItem+.new(..))) && 
   this(object$rac) {
   JMLChecker.hasAnyThrownExceptionalPostconditionSignalsOnly();
  }

/** Generated by AspectJML to enhance error reporting (Execution Site enabled) */
  after() throwing (Throwable rac$e): (execution( * menu.MenuItem..*+.*(..))
          || execution(menu.MenuItem..*+.new(..))
          || execution( * menu.MenuItem+.*(..))
          || execution(menu.MenuItem+.new(..))){
    JMLChecker.hideAjmlSpecificStackTrace(rac$e);
    JMLChecker.rethrowJMLAssertionError(rac$e);
  }

public static aspect UtilPreconditionChecking_MenuItem$d7865686_9d9a_490c_b943_908c8a948d01{
  before(): (execution( * menu.MenuItem..*+.*(..))
          || execution(menu.MenuItem..*+.new(..))
          || execution( * menu.MenuItem+.*(..))
          || execution(menu.MenuItem+.new(..))){
    JMLChecker.hasAnyThrownPrecondition();
  }
}

/** Generated by AspectJML to recover checked exceptions. *
  *  This is based on the exception introduction pattern by Laddad. */
  after(final menu.MenuManager object$rac) throwing(JMLInternalRuntimeException rac$e)
    throws exceptions.NotLoggedInException : (execution(* menu.MenuManager..*+.*(..) throws exceptions.NotLoggedInException) ||
    execution(menu.MenuManager..*+.new(..) throws exceptions.NotLoggedInException) ||
execution(* menu.MenuManager+.*(..) throws exceptions.NotLoggedInException) ||
    execution(menu.MenuManager+.new(..) throws exceptions.NotLoggedInException)) && 
   target(object$rac) {
    Throwable cause = rac$e.getCause();
    if(cause instanceof exceptions.NotLoggedInException) {
      throw (exceptions.NotLoggedInException)cause;
    }
    JMLChecker.rethrowUncheckedException(cause);
  }
  after(final menu.MenuManager object$rac) throwing(JMLInternalRuntimeException rac$e)
    throws exceptions.NonExistentProductId : (execution(* menu.MenuManager..*+.*(..) throws exceptions.NonExistentProductId) ||
    execution(menu.MenuManager..*+.new(..) throws exceptions.NonExistentProductId) ||
execution(* menu.MenuManager+.*(..) throws exceptions.NonExistentProductId) ||
    execution(menu.MenuManager+.new(..) throws exceptions.NonExistentProductId)) && 
   target(object$rac) {
    Throwable cause = rac$e.getCause();
    if(cause instanceof exceptions.NonExistentProductId) {
      throw (exceptions.NonExistentProductId)cause;
    }
    JMLChecker.rethrowUncheckedException(cause);
  }
  after(final menu.MenuManager object$rac) throwing(JMLInternalRuntimeException rac$e)
    throws java.io.IOException : (execution(* menu.MenuManager..*+.*(..) throws java.io.IOException) ||
    execution(menu.MenuManager..*+.new(..) throws java.io.IOException) ||
execution(* menu.MenuManager+.*(..) throws java.io.IOException) ||
    execution(menu.MenuManager+.new(..) throws java.io.IOException)) && 
   target(object$rac) {
    Throwable cause = rac$e.getCause();
    if(cause instanceof java.io.IOException) {
      throw (java.io.IOException)cause;
    }
    JMLChecker.rethrowUncheckedException(cause);
  }

/** Generated by AspectJML to enable modular signals_only checking (XCS enabled) */
  after(final menu.MenuManager object$rac): (execution( * menu.MenuManager..*+.*(..))
          || execution(menu.MenuManager..*+.new(..))
          || execution( * menu.MenuManager+.*(..))
          || execution(menu.MenuManager+.new(..))) && 
   this(object$rac) {
   JMLChecker.hasAnyThrownExceptionalPostconditionSignalsOnly();
  }

/** Generated by AspectJML to enhance error reporting (Execution Site enabled) */
  after() throwing (Throwable rac$e): (execution( * menu.MenuManager..*+.*(..))
          || execution(menu.MenuManager..*+.new(..))
          || execution( * menu.MenuManager+.*(..))
          || execution(menu.MenuManager+.new(..))){
    JMLChecker.hideAjmlSpecificStackTrace(rac$e);
    JMLChecker.rethrowJMLAssertionError(rac$e);
  }

public static aspect UtilPreconditionChecking_MenuManager$a324564d_0003_4ceb_bd30_2993c85b3a33{
  before(): (execution( * menu.MenuManager..*+.*(..))
          || execution(menu.MenuManager..*+.new(..))
          || execution( * menu.MenuManager+.*(..))
          || execution(menu.MenuManager+.new(..))){
    JMLChecker.hasAnyThrownPrecondition();
  }
}

/** Generated by AspectJML to recover checked exceptions. *
  *  This is based on the exception introduction pattern by Laddad. */
  after(final menu.ProductAddingMenu object$rac) throwing(JMLInternalRuntimeException rac$e)
    throws exceptions.NotLoggedInException : (execution(* menu.ProductAddingMenu..*+.*(..) throws exceptions.NotLoggedInException) ||
    execution(menu.ProductAddingMenu..*+.new(..) throws exceptions.NotLoggedInException) ||
execution(* menu.ProductAddingMenu+.*(..) throws exceptions.NotLoggedInException) ||
    execution(menu.ProductAddingMenu+.new(..) throws exceptions.NotLoggedInException)) && 
   target(object$rac) {
    Throwable cause = rac$e.getCause();
    if(cause instanceof exceptions.NotLoggedInException) {
      throw (exceptions.NotLoggedInException)cause;
    }
    JMLChecker.rethrowUncheckedException(cause);
  }
  after(final menu.ProductAddingMenu object$rac) throwing(JMLInternalRuntimeException rac$e)
    throws exceptions.NonExistentProductId : (execution(* menu.ProductAddingMenu..*+.*(..) throws exceptions.NonExistentProductId) ||
    execution(menu.ProductAddingMenu..*+.new(..) throws exceptions.NonExistentProductId) ||
execution(* menu.ProductAddingMenu+.*(..) throws exceptions.NonExistentProductId) ||
    execution(menu.ProductAddingMenu+.new(..) throws exceptions.NonExistentProductId)) && 
   target(object$rac) {
    Throwable cause = rac$e.getCause();
    if(cause instanceof exceptions.NonExistentProductId) {
      throw (exceptions.NonExistentProductId)cause;
    }
    JMLChecker.rethrowUncheckedException(cause);
  }
  after(final menu.ProductAddingMenu object$rac) throwing(JMLInternalRuntimeException rac$e)
    throws java.io.IOException : (execution(* menu.ProductAddingMenu..*+.*(..) throws java.io.IOException) ||
    execution(menu.ProductAddingMenu..*+.new(..) throws java.io.IOException) ||
execution(* menu.ProductAddingMenu+.*(..) throws java.io.IOException) ||
    execution(menu.ProductAddingMenu+.new(..) throws java.io.IOException)) && 
   target(object$rac) {
    Throwable cause = rac$e.getCause();
    if(cause instanceof java.io.IOException) {
      throw (java.io.IOException)cause;
    }
    JMLChecker.rethrowUncheckedException(cause);
  }

/** Generated by AspectJML to enable modular signals_only checking (XCS enabled) */
  after(final menu.ProductAddingMenu object$rac): (execution( * menu.ProductAddingMenu..*+.*(..))
          || execution(menu.ProductAddingMenu..*+.new(..))
          || execution( * menu.ProductAddingMenu+.*(..))
          || execution(menu.ProductAddingMenu+.new(..))) && 
   this(object$rac) {
   JMLChecker.hasAnyThrownExceptionalPostconditionSignalsOnly();
  }

/** Generated by AspectJML to enhance error reporting (Execution Site enabled) */
  after() throwing (Throwable rac$e): (execution( * menu.ProductAddingMenu..*+.*(..))
          || execution(menu.ProductAddingMenu..*+.new(..))
          || execution( * menu.ProductAddingMenu+.*(..))
          || execution(menu.ProductAddingMenu+.new(..))){
    JMLChecker.hideAjmlSpecificStackTrace(rac$e);
    JMLChecker.rethrowJMLAssertionError(rac$e);
  }

public static aspect UtilPreconditionChecking_ProductAddingMenu$d2dac7a8_b319_4213_ad8d_f75497e68430{
  before(): (execution( * menu.ProductAddingMenu..*+.*(..))
          || execution(menu.ProductAddingMenu..*+.new(..))
          || execution( * menu.ProductAddingMenu+.*(..))
          || execution(menu.ProductAddingMenu+.new(..))){
    JMLChecker.hasAnyThrownPrecondition();
  }
}

/** Generated by AspectJML to recover checked exceptions. *
  *  This is based on the exception introduction pattern by Laddad. */
  after(final menu.ProductMenu object$rac) throwing(JMLInternalRuntimeException rac$e)
    throws java.io.IOException : (execution(* menu.ProductMenu..*+.*(..) throws java.io.IOException) ||
    execution(menu.ProductMenu..*+.new(..) throws java.io.IOException) ||
execution(* menu.ProductMenu+.*(..) throws java.io.IOException) ||
    execution(menu.ProductMenu+.new(..) throws java.io.IOException)) && 
   target(object$rac) {
    Throwable cause = rac$e.getCause();
    if(cause instanceof java.io.IOException) {
      throw (java.io.IOException)cause;
    }
    JMLChecker.rethrowUncheckedException(cause);
  }
  after(final menu.ProductMenu object$rac) throwing(JMLInternalRuntimeException rac$e)
    throws exceptions.NotLoggedInException : (execution(* menu.ProductMenu..*+.*(..) throws exceptions.NotLoggedInException) ||
    execution(menu.ProductMenu..*+.new(..) throws exceptions.NotLoggedInException) ||
execution(* menu.ProductMenu+.*(..) throws exceptions.NotLoggedInException) ||
    execution(menu.ProductMenu+.new(..) throws exceptions.NotLoggedInException)) && 
   target(object$rac) {
    Throwable cause = rac$e.getCause();
    if(cause instanceof exceptions.NotLoggedInException) {
      throw (exceptions.NotLoggedInException)cause;
    }
    JMLChecker.rethrowUncheckedException(cause);
  }
  after(final menu.ProductMenu object$rac) throwing(JMLInternalRuntimeException rac$e)
    throws exceptions.NonExistentProductId : (execution(* menu.ProductMenu..*+.*(..) throws exceptions.NonExistentProductId) ||
    execution(menu.ProductMenu..*+.new(..) throws exceptions.NonExistentProductId) ||
execution(* menu.ProductMenu+.*(..) throws exceptions.NonExistentProductId) ||
    execution(menu.ProductMenu+.new(..) throws exceptions.NonExistentProductId)) && 
   target(object$rac) {
    Throwable cause = rac$e.getCause();
    if(cause instanceof exceptions.NonExistentProductId) {
      throw (exceptions.NonExistentProductId)cause;
    }
    JMLChecker.rethrowUncheckedException(cause);
  }

/** Generated by AspectJML to enable modular signals_only checking (XCS enabled) */
  after(final menu.ProductMenu object$rac): (execution( * menu.ProductMenu..*+.*(..))
          || execution(menu.ProductMenu..*+.new(..))
          || execution( * menu.ProductMenu+.*(..))
          || execution(menu.ProductMenu+.new(..))) && 
   this(object$rac) {
   JMLChecker.hasAnyThrownExceptionalPostconditionSignalsOnly();
  }

/** Generated by AspectJML to enhance error reporting (Execution Site enabled) */
  after() throwing (Throwable rac$e): (execution( * menu.ProductMenu..*+.*(..))
          || execution(menu.ProductMenu..*+.new(..))
          || execution( * menu.ProductMenu+.*(..))
          || execution(menu.ProductMenu+.new(..))){
    JMLChecker.hideAjmlSpecificStackTrace(rac$e);
    JMLChecker.rethrowJMLAssertionError(rac$e);
  }

public static aspect UtilPreconditionChecking_ProductMenu$57be0f3a_2805_4b20_acfa_2d2b3a97ae84{
  before(): (execution( * menu.ProductMenu..*+.*(..))
          || execution(menu.ProductMenu..*+.new(..))
          || execution( * menu.ProductMenu+.*(..))
          || execution(menu.ProductMenu+.new(..))){
    JMLChecker.hasAnyThrownPrecondition();
  }
}

/** Generated by AspectJML to recover checked exceptions. *
  *  This is based on the exception introduction pattern by Laddad. */
  after(final menu.ProfileMenu object$rac) throwing(JMLInternalRuntimeException rac$e)
    throws java.io.IOException : (execution(* menu.ProfileMenu..*+.*(..) throws java.io.IOException) ||
    execution(menu.ProfileMenu..*+.new(..) throws java.io.IOException) ||
execution(* menu.ProfileMenu+.*(..) throws java.io.IOException) ||
    execution(menu.ProfileMenu+.new(..) throws java.io.IOException)) && 
   target(object$rac) {
    Throwable cause = rac$e.getCause();
    if(cause instanceof java.io.IOException) {
      throw (java.io.IOException)cause;
    }
    JMLChecker.rethrowUncheckedException(cause);
  }

/** Generated by AspectJML to enable modular signals_only checking (XCS enabled) */
  after(final menu.ProfileMenu object$rac): (execution( * menu.ProfileMenu..*+.*(..))
          || execution(menu.ProfileMenu..*+.new(..))
          || execution( * menu.ProfileMenu+.*(..))
          || execution(menu.ProfileMenu+.new(..))) && 
   this(object$rac) {
   JMLChecker.hasAnyThrownExceptionalPostconditionSignalsOnly();
  }

/** Generated by AspectJML to enhance error reporting (Execution Site enabled) */
  after() throwing (Throwable rac$e): (execution( * menu.ProfileMenu..*+.*(..))
          || execution(menu.ProfileMenu..*+.new(..))
          || execution( * menu.ProfileMenu+.*(..))
          || execution(menu.ProfileMenu+.new(..))){
    JMLChecker.hideAjmlSpecificStackTrace(rac$e);
    JMLChecker.rethrowJMLAssertionError(rac$e);
  }

public static aspect UtilPreconditionChecking_ProfileMenu$9d38524e_9d9b_4f71_9ea5_f13ac5e80f52{
  before(): (execution( * menu.ProfileMenu..*+.*(..))
          || execution(menu.ProfileMenu..*+.new(..))
          || execution( * menu.ProfileMenu+.*(..))
          || execution(menu.ProfileMenu+.new(..))){
    JMLChecker.hasAnyThrownPrecondition();
  }
}

/** Generated by AspectJML to recover checked exceptions. *
  *  This is based on the exception introduction pattern by Laddad. */
  after(final menu.RegistrationMenu object$rac) throwing(JMLInternalRuntimeException rac$e)
    throws java.io.IOException : (execution(* menu.RegistrationMenu..*+.*(..) throws java.io.IOException) ||
    execution(menu.RegistrationMenu..*+.new(..) throws java.io.IOException) ||
execution(* menu.RegistrationMenu+.*(..) throws java.io.IOException) ||
    execution(menu.RegistrationMenu+.new(..) throws java.io.IOException)) && 
   target(object$rac) {
    Throwable cause = rac$e.getCause();
    if(cause instanceof java.io.IOException) {
      throw (java.io.IOException)cause;
    }
    JMLChecker.rethrowUncheckedException(cause);
  }
  after(final menu.RegistrationMenu object$rac) throwing(JMLInternalRuntimeException rac$e)
    throws exceptions.NotLoggedInException : (execution(* menu.RegistrationMenu..*+.*(..) throws exceptions.NotLoggedInException) ||
    execution(menu.RegistrationMenu..*+.new(..) throws exceptions.NotLoggedInException) ||
execution(* menu.RegistrationMenu+.*(..) throws exceptions.NotLoggedInException) ||
    execution(menu.RegistrationMenu+.new(..) throws exceptions.NotLoggedInException)) && 
   target(object$rac) {
    Throwable cause = rac$e.getCause();
    if(cause instanceof exceptions.NotLoggedInException) {
      throw (exceptions.NotLoggedInException)cause;
    }
    JMLChecker.rethrowUncheckedException(cause);
  }
  after(final menu.RegistrationMenu object$rac) throwing(JMLInternalRuntimeException rac$e)
    throws exceptions.NonExistentProductId : (execution(* menu.RegistrationMenu..*+.*(..) throws exceptions.NonExistentProductId) ||
    execution(menu.RegistrationMenu..*+.new(..) throws exceptions.NonExistentProductId) ||
execution(* menu.RegistrationMenu+.*(..) throws exceptions.NonExistentProductId) ||
    execution(menu.RegistrationMenu+.new(..) throws exceptions.NonExistentProductId)) && 
   target(object$rac) {
    Throwable cause = rac$e.getCause();
    if(cause instanceof exceptions.NonExistentProductId) {
      throw (exceptions.NonExistentProductId)cause;
    }
    JMLChecker.rethrowUncheckedException(cause);
  }

/** Generated by AspectJML to enable modular signals_only checking (XCS enabled) */
  after(final menu.RegistrationMenu object$rac): (execution( * menu.RegistrationMenu..*+.*(..))
          || execution(menu.RegistrationMenu..*+.new(..))
          || execution( * menu.RegistrationMenu+.*(..))
          || execution(menu.RegistrationMenu+.new(..))) && 
   this(object$rac) {
   JMLChecker.hasAnyThrownExceptionalPostconditionSignalsOnly();
  }

/** Generated by AspectJML to enhance error reporting (Execution Site enabled) */
  after() throwing (Throwable rac$e): (execution( * menu.RegistrationMenu..*+.*(..))
          || execution(menu.RegistrationMenu..*+.new(..))
          || execution( * menu.RegistrationMenu+.*(..))
          || execution(menu.RegistrationMenu+.new(..))){
    JMLChecker.hideAjmlSpecificStackTrace(rac$e);
    JMLChecker.rethrowJMLAssertionError(rac$e);
  }

public static aspect UtilPreconditionChecking_RegistrationMenu$0bdd4ea9_5da8_4545_86db_756e51313960{
  before(): (execution( * menu.RegistrationMenu..*+.*(..))
          || execution(menu.RegistrationMenu..*+.new(..))
          || execution( * menu.RegistrationMenu+.*(..))
          || execution(menu.RegistrationMenu+.new(..))){
    JMLChecker.hasAnyThrownPrecondition();
  }
}

/** Generated by AspectJML to recover checked exceptions. *
  *  This is based on the exception introduction pattern by Laddad. */
  after(final menu.StoreMenu object$rac) throwing(JMLInternalRuntimeException rac$e)
    throws java.io.IOException : (execution(* menu.StoreMenu..*+.*(..) throws java.io.IOException) ||
    execution(menu.StoreMenu..*+.new(..) throws java.io.IOException) ||
execution(* menu.StoreMenu+.*(..) throws java.io.IOException) ||
    execution(menu.StoreMenu+.new(..) throws java.io.IOException)) && 
   target(object$rac) {
    Throwable cause = rac$e.getCause();
    if(cause instanceof java.io.IOException) {
      throw (java.io.IOException)cause;
    }
    JMLChecker.rethrowUncheckedException(cause);
  }
  after(final menu.StoreMenu object$rac) throwing(JMLInternalRuntimeException rac$e)
    throws exceptions.NotLoggedInException : (execution(* menu.StoreMenu..*+.*(..) throws exceptions.NotLoggedInException) ||
    execution(menu.StoreMenu..*+.new(..) throws exceptions.NotLoggedInException) ||
execution(* menu.StoreMenu+.*(..) throws exceptions.NotLoggedInException) ||
    execution(menu.StoreMenu+.new(..) throws exceptions.NotLoggedInException)) && 
   target(object$rac) {
    Throwable cause = rac$e.getCause();
    if(cause instanceof exceptions.NotLoggedInException) {
      throw (exceptions.NotLoggedInException)cause;
    }
    JMLChecker.rethrowUncheckedException(cause);
  }
  after(final menu.StoreMenu object$rac) throwing(JMLInternalRuntimeException rac$e)
    throws exceptions.NonExistentProductId : (execution(* menu.StoreMenu..*+.*(..) throws exceptions.NonExistentProductId) ||
    execution(menu.StoreMenu..*+.new(..) throws exceptions.NonExistentProductId) ||
execution(* menu.StoreMenu+.*(..) throws exceptions.NonExistentProductId) ||
    execution(menu.StoreMenu+.new(..) throws exceptions.NonExistentProductId)) && 
   target(object$rac) {
    Throwable cause = rac$e.getCause();
    if(cause instanceof exceptions.NonExistentProductId) {
      throw (exceptions.NonExistentProductId)cause;
    }
    JMLChecker.rethrowUncheckedException(cause);
  }

/** Generated by AspectJML to enable modular signals_only checking (XCS enabled) */
  after(final menu.StoreMenu object$rac): (execution( * menu.StoreMenu..*+.*(..))
          || execution(menu.StoreMenu..*+.new(..))
          || execution( * menu.StoreMenu+.*(..))
          || execution(menu.StoreMenu+.new(..))) && 
   this(object$rac) {
   JMLChecker.hasAnyThrownExceptionalPostconditionSignalsOnly();
  }

/** Generated by AspectJML to enhance error reporting (Execution Site enabled) */
  after() throwing (Throwable rac$e): (execution( * menu.StoreMenu..*+.*(..))
          || execution(menu.StoreMenu..*+.new(..))
          || execution( * menu.StoreMenu+.*(..))
          || execution(menu.StoreMenu+.new(..))){
    JMLChecker.hideAjmlSpecificStackTrace(rac$e);
    JMLChecker.rethrowJMLAssertionError(rac$e);
  }

public static aspect UtilPreconditionChecking_StoreMenu$cc0625ff_dae4_4697_a091_267a53f237ef{
  before(): (execution( * menu.StoreMenu..*+.*(..))
          || execution(menu.StoreMenu..*+.new(..))
          || execution( * menu.StoreMenu+.*(..))
          || execution(menu.StoreMenu+.new(..))){
    JMLChecker.hasAnyThrownPrecondition();
  }
}

/** Generated by AspectJML to recover checked exceptions. *
  *  This is based on the exception introduction pattern by Laddad. */
  after(final testdata.DataFactory object$rac) throwing(JMLInternalRuntimeException rac$e)
    throws java.io.IOException : (execution(* testdata.DataFactory..*+.*(..) throws java.io.IOException) ||
    execution(testdata.DataFactory..*+.new(..) throws java.io.IOException) ||
execution(* testdata.DataFactory+.*(..) throws java.io.IOException) ||
    execution(testdata.DataFactory+.new(..) throws java.io.IOException)) && 
   target(object$rac) {
    Throwable cause = rac$e.getCause();
    if(cause instanceof java.io.IOException) {
      throw (java.io.IOException)cause;
    }
    JMLChecker.rethrowUncheckedException(cause);
  }

/** Generated by AspectJML to enable modular signals_only checking (XCS enabled) */
  after(final testdata.DataFactory object$rac): (execution( * testdata.DataFactory..*+.*(..))
          || execution(testdata.DataFactory..*+.new(..))
          || execution( * testdata.DataFactory+.*(..))
          || execution(testdata.DataFactory+.new(..))) && 
   this(object$rac) {
   JMLChecker.hasAnyThrownExceptionalPostconditionSignalsOnly();
  }

/** Generated by AspectJML to enhance error reporting (Execution Site enabled) */
  after() throwing (Throwable rac$e): (execution( * testdata.DataFactory..*+.*(..))
          || execution(testdata.DataFactory..*+.new(..))
          || execution( * testdata.DataFactory+.*(..))
          || execution(testdata.DataFactory+.new(..))){
    JMLChecker.hideAjmlSpecificStackTrace(rac$e);
    JMLChecker.rethrowJMLAssertionError(rac$e);
  }

public static aspect UtilPreconditionChecking_DataFactory$5e0cbc10_9bdc_43c3_9fba_fbcce8827a16{
  before(): (execution( * testdata.DataFactory..*+.*(..))
          || execution(testdata.DataFactory..*+.new(..))
          || execution( * testdata.DataFactory+.*(..))
          || execution(testdata.DataFactory+.new(..))){
    JMLChecker.hasAnyThrownPrecondition();
  }
}

}